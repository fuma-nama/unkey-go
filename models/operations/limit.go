// Code generated by Speakeasy (https://speakeasyapi.com). DO NOT EDIT.

package operations

import (
	"github.com/unkeyed/unkey-go/internal/utils"
	"github.com/unkeyed/unkey-go/models/components"
)

type Resources struct {
	// The type of resource
	Type string `json:"type"`
	// The unique identifier for the resource
	ID string `json:"id"`
	// A human readable name for this resource
	Name *string `json:"name,omitempty"`
	// Attach any metadata to this resources
	Meta map[string]any `json:"meta,omitempty"`
}

func (o *Resources) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *Resources) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Resources) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Resources) GetMeta() map[string]any {
	if o == nil {
		return nil
	}
	return o.Meta
}

type LimitRequestBody struct {
	// Namespaces group different limits together for better analytics. You might have a namespace for your public API and one for internal tRPC routes.
	Namespace *string `default:"default" json:"namespace"`
	// Identifier of your user, this can be their userId, an email, an ip or anything else.
	Identifier string `json:"identifier"`
	// How many requests may pass in a given window.
	Limit int64 `json:"limit"`
	// The window duration in milliseconds
	Duration int64 `json:"duration"`
	// Expensive requests may use up more tokens. You can specify a cost to the request here and we'll deduct this many tokens in the current window.
	// If there are not enough tokens left, the request is denied.
	//
	// Set it to 0 to receive the current limit without changing anything.
	Cost *int64 `default:"1" json:"cost"`
	// Async will return a response immediately, lowering latency at the cost of accuracy.
	Async *bool `default:"false" json:"async"`
	// Attach any metadata to this request
	Meta map[string]any `json:"meta,omitempty"`
	// Resources that are about to be accessed by the user
	Resources []Resources `json:"resources,omitempty"`
}

func (l LimitRequestBody) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LimitRequestBody) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *LimitRequestBody) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *LimitRequestBody) GetIdentifier() string {
	if o == nil {
		return ""
	}
	return o.Identifier
}

func (o *LimitRequestBody) GetLimit() int64 {
	if o == nil {
		return 0
	}
	return o.Limit
}

func (o *LimitRequestBody) GetDuration() int64 {
	if o == nil {
		return 0
	}
	return o.Duration
}

func (o *LimitRequestBody) GetCost() *int64 {
	if o == nil {
		return nil
	}
	return o.Cost
}

func (o *LimitRequestBody) GetAsync() *bool {
	if o == nil {
		return nil
	}
	return o.Async
}

func (o *LimitRequestBody) GetMeta() map[string]any {
	if o == nil {
		return nil
	}
	return o.Meta
}

func (o *LimitRequestBody) GetResources() []Resources {
	if o == nil {
		return nil
	}
	return o.Resources
}

type LimitResponseBody struct {
	// Returns true if the request should be processed, false if it was rejected.
	Success bool `json:"success"`
	// How many requests are allowed within a window.
	Limit int64 `json:"limit"`
	// How many requests can still be made in the current window.
	Remaining int64 `json:"remaining"`
	// A unix millisecond timestamp when the limits reset.
	Reset int64 `json:"reset"`
}

func (o *LimitResponseBody) GetSuccess() bool {
	if o == nil {
		return false
	}
	return o.Success
}

func (o *LimitResponseBody) GetLimit() int64 {
	if o == nil {
		return 0
	}
	return o.Limit
}

func (o *LimitResponseBody) GetRemaining() int64 {
	if o == nil {
		return 0
	}
	return o.Remaining
}

func (o *LimitResponseBody) GetReset() int64 {
	if o == nil {
		return 0
	}
	return o.Reset
}

type LimitResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	Object   *LimitResponseBody
}

func (o *LimitResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *LimitResponse) GetObject() *LimitResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
